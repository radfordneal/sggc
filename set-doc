FACILITY FOR MAINTAINING SETS OF OBJECTS IN SEGMENTS

Copyright (c) 2016 Radford M. Neal.

   This is part of the SGGC library, which is free software.  You can
   redistribute it and/or modify it under the terms of the GNU General
   Public License as published by the Free Software Foundation; either
   version 2 of the License, or (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


INTRODUCTION

This set facility is designed to support the SGGC functions, but could
be used for other purposes, and hence is documented separately here.

The set facility manages sets of "values", each of which is in a
"segment".  The number of possible values in a segment is fixed and in
the present implementation is limited to a power of two between 8 and
64 (larger values would require new coding and have a performance
cost).  Not all the values allowed in a segment need exist.  Segments
have integer indexes from 0 up, and values within a segment have
offsets that are integers from 0 to the number of possible values in a
segment minus one.  A value within a segment is identified by the pair
of segment index and offset within segment, which must fit in 32 bits
(though expanding this to 64 bits would be possible).

Each set is associated with a "chain", with the restriction that two
sets sharing the same chain must not both contain values that are in
the same segment.  For some purposes, a chain can be regarded as a set
that is the union of all sets sharing that chain.  The number of
chains is intended to be small, and this number must be fixed at
compile time.  The number of sets using these chains is not
restricted, and sets could be dynamically created, though it is
anticipated that the number of sets will be static and fairly small.

For some operations, the values in a set are ordered.  This ordering
always groups values within one segment together, and the ordering
within a segment is always by numeric offset within the segment.

Each segment is associated with a data structure that contains, for
every chain, a bit vector indicating which values within the segment
are members of some set using that chain, along with the index of a
following segment containing further members of this set (or an end
flag).  The structure describing a set contains the identifier of the
chain it uses, the index of the first segment containing members of
the set (or an end flag, if there are none), and a count of how many
elements are in the set.

Functions are provided for testing membership in a set, adding a value
to a set, removing a value, and scanning values in a set in order,
finding the number of elements in a set, and some other operations.


USING THE SET FACILITY

To use the set facility, an application should create a set-app.h
file, which must start by defining some constants (see below), then
include the set.h file, and conclude with some additional declarations
(see below).

The following constants are declared with #define at the start of
set-app.h:

  SET_OFFSET_BITS  Number of bits in the "offset" of a value.  Must be
                   3, 4, 5, or 6, corresponding to 8, 16, 32, or 64
                   possible values in a segment.

  SET_CHAINS       Number of chains that may be used for sets.  Must
                   be at least 1.  Larger values will result in 
                   more memory being used for every segment.

  SET_EXTRA_INFO   (optional) If desired, a declaration for additional
                   information that is stored in the structure for a
                   segment.  This might allow space to be used that 
                   would otherwise be wasted as padding for alignment.
                   Should have the form of a structure field, including
                   the terminating semicolon.

For convenience, the application might also at this point define
symbols for the chains, which are identified by integers from 0 to
SET_CHAINS-1, though these symbols would be use only by the
application itself.  The definition of SET_EXTRA_INFO might involve
various other declarations.

The set.h file should then be included in set-app.h.  It will define
the following types:

  set_offset_t     The type of the offset of a value within a segment.
                   Currently a generic int.  Not used in structures.

  set_index_t      The type of the index used to identify a segment.
                   Currently int32_t.

  set_value_t      The type holding a value - an (index,offset) pair.
                   Currently uint32_t.

  struct set_segment  Structure holding information on a segment.
                      Fields of this should not be accessed directly.

  struct set          Structure holding information on a set.
                      Fields of this should not be accessed directly.

The following constant is also defined in set.h:

  SET_NO_VALUE     A constant of type set_value_t that cannot be an
                   actual value, and hence can be used to indicate
                   the absence of a value.

Finally, the set.h file will declare prototypes (or macros, or static
inline definitions) for the functions documented below.

After including set.h, the application should declare a macro or
function, which if a function should have the following prototype:

  struct set_segment *SET_SEGMENT (set_index_t index);

This function (or macro) must return the pointer to the segment
information for the segment with the given index.  It is up to the
application to decide how memory for segment structures is allocated
(eg, a static array, or using an array of pointers to structures
allocated with malloc), and hence how a pointer is found from an
index.

The set-app.h file should be included in application modules that use
the set facility.  It will also be included in the set.c file that
defines the functions implementing the set operations.


FUNCTIONS IMPLEMENTING SET OPERATIONS

The following functions (or macros) are provided by the set facility
for use in an application, with prototypes (if functions) as shown:

  set_value_t SET_VAL (set_index_t index, set_offset_t offset)

  set_index_t SET_VAL_INDEX (set_value_t val)

  set_offset_t SET_VAL_OFFSET (set_value_t val)

  void set_init (struct set *set, int chain)

  void set_segment_init (struct set_segment *seg)

  int set_contains (struct set *set, set_value_t val)

  int set_chain_contains (int chain, set_value_t val)

  int set_add (struct set *set, set_value_t val)

  int set_remove (struct set *set, set_value_t val)

  set_value_t set_first (struct set *set, int remove)

  set_value_t set_next (struct set *set, set_value_t val, int remove)

  set_bits_t set_first_bits (struct set *set)

  set_bits_t set_segment_bits (struct set *set, set_value_t val)

  void set_assign_segment_bits (struct set *set, set_value_t val, set_bits_t b)

  void set_move_first (struct set *src, struct set *dst)

  void set_move_next (struct set *src, set_value_t val, struct set *dst)

  set_value_t set_n_elements (struct set *set)

