SGGC - A LIBRARY SUPPORTING SEGMENTED GENERATIONAL GARBAGE COLLECTION
       Application interface documentation

Copyright (c) 2016 Radford M. Neal.

   The SGGC library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


INTRODUCTION

This library manages memory for "objects" that contain data, which may
include references to other objects.  It is designed for use by an
interpreter for a language such as R, though use in other applications
would also be possible.

The SGGC library provides the application with a function for
allocating a new object.  Memory for objects that are no longer in use
is automatically freed or reused.  To allow this, the application must
provide procedures for finding all "root" pointers, and for finding
all pointers to other objects that are contained in an object.  The
application also provides information regarding "types" of objects,
and how much storage they require, which for the main data storage may
vary by type (according to more detailed "kind" information).

Objects are allocated in "segments", and can be referenced by a pair
consisting of a segment index and an offset within a segment.  Such
"compressed pointers" will fit in a 32-bit word (with the current
configuration of SGGC), even when regular pointers are 64 bits in
size.  SGGC is designed to allow fast translation of a compressed
pointer to a regular pointer to data (which for "small" segments is
allocated as a block for all objects in the segment).  An application
may optionally choose for objects to be associated with one or two
pieces of auxiliary information, also quickly accessible using a
compressed pointer.  Unlike the main data, auxiliary information has
the same size for all objects.  An application can make auxiliary
information for some objects be read-only, and shared with other
objects.

An application can choose whether to use compressed pointers for all
object references, or (for the application's purposes) to sometimes or
always use regular pointers.  If regular pointers are used, however,
each object will need to store a compressed pointer to itself in its
data space, to allow translation from regular to compressed pointers,
as the application must sometimes pass compressed pointers to SGGC.

Memory is freed using a "mark and sweep" garbage collector, with three
"generations" of objects, allowing quick recovery of recently
allocated objects without the cost of a full sweep.  The SGGC library
does not decide when a garbage collection (at any of the three levels)
will be done, but instead provides information allowing the
application to implement a policy in this regard.


USING SGGC IN AN APPLICATION

To use SGGC, an application should create an sggc-app.h file, which
must define some constants and declare some types (see below) and then
include the sggc.h file.

The following constants must be declared with #define in set-app.h,
before including sggc.h:

  SGGC_CHUNK_SIZE       Number of bytes in a data chunk.  Should be a 
                        power of two for efficiency.

  SGGC_N_TYPES          Number of types of objects.

  SGGC_N_KINDS          Number of kinds of objects (at least SGGC_N_TYPES).

  SGGC_KIND_CHUNKS      An array initializer giving the number of data 
                        chunks for each kind of object, 0 if the kind uses
                        "big" segments (with variable numbers of chunks).

The following may optionally be defined, if auxiliary information 1 or
auxiliary information 2 is to be used:

  SGGC_AUX1_SIZE        Number of bytes in auxiliary information 1 
                        (same for all kinds of objects).  Should be
                        a power of two for efficiency

  SGGC_AUX2_SIZE        As above, but for auxiliary information 2.

  SGGC_AUX1_BLOCK_SIZE  Number of blocks of auxiliary information 1
                        allocated at once.  (Each block has space for
                        auxiliary information for as many objects 
                        as there are data chunks for a small segment.)

  SGGC_AUX2_BLOCK_SIZE  As above, but for auxiliary information 2.

  SGGC_AUX1_READ_ONLY   If defined (as anything), the application may
                        sometimes use read-only auxiliary information 1.

  SGGC_AUX2_READ_ONLY   As above, but for auxiliary information 2.

The following symbol may be defined to indicate that the application
needs to perform operations after preliminary marking of objects in
use during a garbage collection:

  SGGC_AFTER_MARKING    If defined (as anything), the application will
                        provide an sggc_after_marking procedure to call
                        after preliminary marking of objects (see below).

The following types must be defined in sggc-app.h:

  sggc_length_t         Type for the "length" of an object.  The
                        meaning of "length" is up to the application, 
                        but it is used in the SGGC interface.

  sggc_nchunks_t        Type for holding the number of chunks (with
                        SGGC_CHUNK_SIZE bytes) in the data for an
                        object.

An application may optionally define the following in sggc-app.h:

  sggc_malloc           May be defined as a simple symbol or as a 
                        one-argument macro (not a function), which
                        is used by SGGC to allocate memory blocks.
                        Defaults to the symbol 'malloc'.

  sggc_free             May be defined as a simple symbol or as a 
                        one-argument macro (not a function), which is
                        used by SGGC to free blocks of memory that
                        were allocated by sggc_malloc.  Defaults to
                        the symbol 'free'.

The sggc.h file should be included after the above have been defined,
at the end of sggc-app.h.  It will define the following types:

  sggc_index_t          Type for holding the index of a segment.
                        Currently int32_t.

  sggc_cptr_t           Type for holding a compressed pointer.
                        Currently uint32_t.

  sggc_type_t           Type for holding an object type.
                        Currently unsigned char.

  sggc_kind_t           Type for holding an object kind (type & storage).
                        Currently unsigned char.

The following constants are also defined in sggc.h:

  SGGC_NO_OBJECT        A constant of type sggc_cptr_t that cannot be a
                        reference to an actual object, and hence can be
                        used to indicate "no object".

  SGGC_CHUNKS_IN_SMALL_SEGMENT  The number of chunks (each of size
                                SGGC_CHUNK_SIZE) for the data associated
                                with all objects in a "small" segment.

The sggc.h file will declare the following global structure variable,
which SGGC will continually update with information that the
application may use when deciding whether to call sggc_collect to do a
garbage collection:

  extern struct sggc_info
  {
    unsigned gen0_count;       /* Number of newly-allocated objects */
    unsigned gen1_count;       /* Number of objects in old generation 1 */
    unsigned gen2_count;       /* Number of objects in old generation 2.
                                  Does not include constants */

    sggc_nchunks_t big_chunks; /* # of chunks in newly-allocated big objects */

} sggc_info;

Finally, the sggc.h file will declare prototypes (or macros, or static
inline definitions) for the functions documented below, some of which
may be used by the application, others of which must be defined by the
application for use by SGGC.


TYPES, LENGTHS, AND KINDS

SGGC supports objects that are of different "types", identified by
integers from 0 to SGGC_N_TYPES-1, where SGGC_N_TYPES is defined by
the application (limited to being no bigger than 256).  Types of
objects are recorded by SGGC, but otherwise the meaning of a type is
up to the application.  Note that all objects in a segment will have
the same type.

The application also determines the meaning (if any) of the "length"
of an object - SGGC simply passes length values provided by the
application to functions the application defines.  It would be
possible for the application to completely ignore "length", just
passing some dummy value where a length is required.  More commonly,
however, the length will be used by the application when determining
the "kind" of an object.

All objects in a segment will be of the same kind, identified by a
number from 0 to SGGC_N_KINDS-1, where SGGC_N_KINDS is defined by the
application (limited to being no bigger than 256).  Some kinds are for
"big" segments, which can have data of any size.  Other kinds are for
"small" segments, in which the data associated with an object consists
of a fixed number of chunks (though objects need not use the entirety
of the data space allocated to them).  Whether a kind is for big or
small segments, and the number of chunks allocated for objects if they
are of a small kind, are determined by the value for SGGC_KIND_CHUNKS
that the application provides, which gives the numbers of chunks for
each kind, with zero indicating that the kind uses big segments.

The application provides a function (or macro) sggc_kind that
determines the kind of an object from its type and length.  The kind
returned by sggc_kind must not the same for different types (ie, the
type must be determinable from the kind).  There is also a restriction
that if the kind is for a big segment, it must be numerically equal to
the type.  Accordingly, for each type, there can be at most one kind
using big segments, though there could be several kinds for that type
that use small segments, perhaps with different numbers of data
chunks, depending on length.

The application also provides an sggc_nchunk function (or macro) that
returns the number of data chunks needed for an object of given type
and length.  This is called when SGGC needs to allocate space for a
big segment.

For example, the application might have the following definitions in
its sggc-app.h file:

  #define SGGC_CHUNK_SIZE 16 /* Number of bytes in a data chunk */
  #define SGGC_N_TYPES 3     /* Three types of objects: 0, 1, 2 */
  #define SGGC_N_KINDS 5     /* Five kinds of objects 0, 1, 2, 3, 4 */

  #define SGGC_KIND_CHUNKS \
                  { 1,       /* Kind 0 uses one data chunk, for type 0 */ \
                    2,       /* Kind 1 uses two data chunks, for type 1 */ \
                    0,       /* Kind 2 uses big segments, for type 2 */ \
                    1,       /* Kind 3 uses one data chunk, for type 2 */ \
                    3        /* Kind 4 uses three data chunks, for type 2 */ \
  }

  #define sggc_kind(type,length) \
    ((type) < 2 ? (type)     /* Types 0 and 1 use kinds 0 and 1 */ \
    : (length) <= 2 ? 3      /* Type 2 with length 2 or less can use kind 3 */ \
    : (length) <= 6 ? 4      /* Type 2 with length 6 or less can use kind 4 */ \
    : 2)                     /* Type 2 with length >6 must use a big segment */

  #define sggc_nchunks(type,length) \
    ((sggc_nchunks_t)(length) * 2) /* Number of chunks needed is twice length */

If an application defines the symbols SGGC_AUX1_READ_ONLY, it must
also provide a function called sggc_aux1_read_only that returns
read-only auxiliary information 1 for a segment of a given kind, or
NULL if this information is not read-only for segments of this kind.
If SGGC_AUX1_READ_ONLY is defined, the application must similarly
provide an sggc_aux2_read_only function.


FUNCTIONS PROVIDED BY SGGC TO THE APPLICATION

The SGGC library provides an application with the functions (or
macros) below, which have (if functions) prototypes as shown:

  sggc_type_t SGGC_TYPE (sggc_cptr_t cptr)

    Returns the type of the object whose compressed pointer is passed,
    an integer from 0 to SGGC_N_TYPES-1.

  sggc_type_t SGGC_KIND (sggc_cptr_t cptr)

    Returns the kind of the object whose compressed pointer is passed,
    an integer from 0 to SGGC_N_KIND-1.

  char *SGGC_DATA (sggc_cptr_t cptr)

    Returns a regular pointer to the data associated with the object
    whose compressed pointer is passed.

  char *SGGC_AUX1 (sggc_cptr_t cptr)   (only if SGGC_AUX1_SIZE defined)

    Returns a regular pointer to the auxiliary information 1 for the
    object whose compressed pointer is passed.

  char *SGGC_AUX2 (sggc_cptr_t cptr)   (only if SGGC_AUX2_SIZE defined)

    Returns a regular pointer to the auxiliary information 2 for the
    object whose compressed pointer is passed.

  int sggc_init (int max_segments)

    Initializes the SGGC facility, with the maximum number of segments
    being as specified.

  sggc_cptr_t sggc_alloc (sggc_type_t type, sggc_length_t length)

    Allocates space for an object of the specified type and length,
    returning a compressed pointer to the object, or SGGC_NO_OBJECT if
    space could not be allocated.  If SGGC_NO_OBJECT is returned, it
    is possible that if a garbage collection is then performed using
    sggc_collect, a subsequent call of sggc_alloc for the same type
    and length will succeed (though this will not always be the case).

    Note that the significant of type and length for the storage that
    is needed is determined by the application, via the sggc_kind
    function and the SGGC_KIND_CHUNKS initializer.

  void sggc_collect (int level)

    Peforms a garbage collection operation, at the specified level.
    Level 0 attempts to recover only unused object that were allocated
    since the last garbage collection.  Level 1 also attempts to
    recover unused objects that have survived one garbage collection
    (only).  Level 2 attempts to recover all unused objects (except
    constants).

    Note that this function is never called automatically by SGGC.  
    It is up to the application to implement a policy for when to call
    the garbage collector, and at what level.

  int sggc_look_at (sggc_cptr_t cptr)

  void sggc_old_to_new_check (sggc_cptr_t from_ptr, sggc_cptr_t to_ptr)

  int sggc_youngest_generation (sggc_cptr_t from_ptr)

  int sggc_oldest_generation (sggc_cptr_t to_ptr)

  int sggc_not_marked (sggc_cptr_t cptr)

  int sggc_is_constant (sggc_cptr_t cptr)

  sggc_cptr_t sggc_constant (sggc_type_t type, sggc_kind_t kind, 
                             set_bits_t bits, char *data, 
                             char *aux1, char *aux2)


FUNCTIONS THE APPLICATION MUST PROVIDE TO SGGC

The application defines the following functions (which could instead
be macros), which are called from the SGGC library functions:

  sggc_kind_t sggc_kind (sggc_type_t type, sggc_length_t length)

    Returns the "kind" of a segment to be used for objects of the
    given type and length, identified by an integer from 0 to
    SGGC_N_KINDS-1.  Must return the same kind on all calls with the
    same type and length, and must return different kinds for
    different types.

  sggc_nchunks_t sggc_nchunks (sggc_type_t type, sggc_length_t length)

    Returns the number of data chunks required for an object of the
    given type and length.  Called only when allocating space for big
    segments, so need handled only type and length combinations for
    which sggc_kind returns the kind of a big segment.

  void sggc_find_root_ptrs (void)

  void sggc_find_object_ptrs (sggc_cptr_t cptr)

  char *sggc_aux1_read_only (sggc_kind_t kind)  (if def SGGC_AUX1_READ_ONLY)

  char *sggc_aux2_read_only (sggc_kind_t kind)  (if def SGGC_AUX2_READ_ONLY)

  void sggc_after_marking (int level, int rep)  (if def SGGC_AFTER_MARKING)
