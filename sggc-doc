SGGC - A LIBRARY SUPPORTING SEGMENTED GENERATIONAL GARBAGE COLLECTION
       Application interface documentation

Copyright (c) 2016, 2017, 2018 Radford M. Neal.

   The SGGC library is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


INTRODUCTION

This library manages memory for "objects" that contain data, which may
include references to other objects.  It is designed for use by an
interpreter for a language such as R, though use in other applications
would also be possible.

The SGGC library provides the application with a function for
allocating a new object.  Memory for objects that are no longer in use
is automatically freed or reused, when the application initiates a
garbage collection.  To allow identification and recovery of unused
objects, the application must provide procedures for finding all
"root" pointers to objects, and for finding all pointers to other
objects that are contained in an object.  The application also
provides information regarding "types" of objects, and how much
storage they require, which for the main data storage may vary by type
(according to more detailed "kind" information).

Objects are allocated in "segments", and can be referenced by a pair
consisting of a segment index and an offset within a segment.  Such
"compressed pointers" will fit in a 32-bit word (with the current
configuration of SGGC), even when regular pointers are 64 bits in
size.  SGGC is designed to allow fast translation of a compressed
pointer to a regular pointer to data (which for "small" segments is
allocated as a block for all objects in the segment).  An application
may optionally choose for objects to be associated with one or two
pieces of auxiliary information, also quickly accessible using a
compressed pointer.  Unlike the main data, auxiliary information has
the same size for all objects.  An application can make auxiliary
information for some objects be read-only, and shared with other
objects.

An application can choose whether to use compressed pointers for all
object references, or (for the application's purposes) to sometimes or
always use regular pointers.  If regular pointers are used, however,
each object will need to store a compressed pointer to itself in its
data space, to allow translation from regular to compressed pointers,
as the application must sometimes pass compressed pointers to SGGC.

Memory is freed using a "mark and sweep" garbage collector, with three
"generations" of objects, often allowing quick recovery of recently
allocated objects without the cost of a full sweep (depending on the
"level" of collection).  It is also possible to create objects that
are never collected (but which may contain references to collected
objects), which might be regarded as being of an even older
generation.

The SGGC library does not decide when a garbage collection will be
done, or at what level, but instead provides information allowing the
application to implement a policy in this regard.


USING SGGC IN AN APPLICATION

To use SGGC, an application should create an sggc-app.h file, which
must define some constants and declare some types (see below) and then
include the sggc.h file.  The sggc-app.h file should be included in
application modules that use the SGGC library, and is also included in
the source file for the SGGC library routines.  If SGGC_NO_FUNCTIONS
is defined before sggc-app.h is included, non-inline function
declarations in sggc.h will be omitted, with only types, macros, and
inline functions defined.

The following constants must be declared with #define in sggc-app.h,
before it includes sggc.h:

  SGGC_CHUNK_SIZE       Number of bytes in a data chunk.  Should be a 
                        power of two for efficiency, and must be a
                        multiple of 8 for alignment reasons.

  SGGC_N_TYPES          Number of types of objects.

  SGGC_N_KINDS          Number of kinds of objects (at least SGGC_N_TYPES).

  SGGC_KIND_CHUNKS      An array initializer giving the number of data 
                        chunks for each kind of object, 0 if the kind uses
                        "big" segments (with variable numbers of chunks).

The following constant must be defined if the sggc_alloc_kind or
sggc_alloc_small_kind function is used (see below):

  SGGC_KIND_TYPES       An array initializer giving the type for each
                        kind of object.

The following constant must be defined if some kinds of objects are
never collected as garbage (see below), and should be left undefined
if uncollected objects are not used by the application:

  SGGC_KIND_UNCOLLECTED An initializer for an array of 0 / 1 values 
                        specifying which kinds of objects are never
                        collected (1 means not collected).

The following may optionally be defined, if auxiliary information 1 or
auxiliary information 2 is to be used:

  SGGC_AUX1_SIZE        Number of bytes in auxiliary information 1 
                        (same for all kinds of objects).  Should be
                        a power of two for efficiency.

  SGGC_AUX2_SIZE        As above, but for auxiliary information 2.

  SGGC_AUX1_BLOCK_SIZE  Number of blocks of auxiliary information 1
                        allocated at once.  Each block has space for
                        auxiliary information for as many objects as
                        there are data chunks for a small segment.
                        The total number of items of auxiliary
                        information allocated at once must be no more
                        than 256 (since offsets in it are stored in an
                        unsigned char).

  SGGC_AUX2_BLOCK_SIZE  As above, but for auxiliary information 2.

  SGGC_AUX1_READ_ONLY   If defined (as anything), the application may
                        sometimes use read-only auxiliary information 1.

  SGGC_AUX2_READ_ONLY   As above, but for auxiliary information 2.

The following symbol may be defined to indicate that the application
needs to perform operations after preliminary marking of objects in
use during a garbage collection:

  SGGC_AFTER_MARKING    If defined (as anything), the application will
                        provide an sggc_after_marking procedure to call
                        after preliminary marking of objects (see below).
                        This procedure may call sggc_not_marked to see
                        which objects are known to be in use, and may
                        call sggc_look_at (or sggc_mark) to mark 
                        additional objects as in use.

The following may be defined to specify the maximum number of segments
allowed at compile time, so that they will be statically rather than
dynamically allocated (for a possible speed advantage in data access):

  SGGC_MAX_SEGMENTS     The maximum number of segments allowed. If it
                        is specified, space is statically allocated
                        for pointers to segment data (or for the
                        segment data itself, if SGGC_SEG_DIRECT is
                        defined), and the argument to sggc_init can
                        only reduce this limit, not increase it.

The symbols below may be defined if the application wishes bytes of
memory for objects found to be free after a garbage collection to be
set to some value, as a measure to make errors in which freed memory
is still referenced more apparent.  There is a fairly large, but not
extreme, performance penalty for doing this.  Note that sometimes
freed memory will cease to be mapped into the address space, in which
case accessing it will cause a program crash.  Note also that memory
for freed objets may be reused for other objects, unless the program
calls sggc_no_reuse (see below).

  SGGC_CLEAR_FREE       If defined (as anything), bytes in the data
                        area and the auxiliary information (if not
                        read-only) for an object are set to constants
                        when it becomes free.

  SGGC_CLEAR_DATA_BYTE  The byte to set free data areas to; default 0.

  SGGC_CLEAR_AUX1_BYTE  The byte to set free auxiliary information 1
                        to, if it is not read-only; default 0.

  SGGC_CLEAR_AUX2_BYTE  The byte to set free auxiliary information 2 
                        to, if it is not read-only; default 0.

The following may be defined to change the bit pattern used to
represent SGGC_NO_OBJECT:

  SGGC_NO_OBJECT_ZERO   If defined (as anything), SGGC_NO_OBJECT will
                        be represented by all 0 bits, rather than the
                        default of all 1 bits.

The following may be define to change the interface used for
communicating references to objects that are in use:

  SGGC_FIND_OBJECT_RETURN  If defined (as anything), an alternative
                           interface is used for sggc_find_object_ptrs
                           (as described below).

The following may be defined to ensure that data areas are initialized
to zeros:

  SGGC_DATA_ALLOC_ZERO  If defined (as anything), the data area of an
                        object allocated with sggc_alloc (or related
                        functions) will be initialized to all zero
                        bits.  Otherwise, the contents of the data
                        area for a new object are undefined.

The following types must be defined in sggc-app.h:

  sggc_length_t         Type for the "length" of an object.  The
                        meaning of "length" is up to the application, 
                        but it is used in the SGGC interface.

  sggc_nchunks_t        Type for holding the number of chunks (with
                        SGGC_CHUNK_SIZE bytes) in the data for an
                        object.

An application may optionally define the following in sggc-app.h:

  sggc_mem_alloc_zero   May be defined as a simple symbol or as a 
                        one-argument macro (not a function), which
                        is used by SGGC to allocate a block of memory
                        with the given number of bytes, which must be 
                        set to all zero bits, with return of NULL 
                        indicating failure.  The memory must be aligned
                        to an 8-byte boundary.  Defaults to a call of
                        the C library 'calloc' function.

  sggc_mem_alloc        May be defined as a simple symbol or as a 
                        one-argument macro (not a function), which is
                        used by SGGC to allocate a block of memory
                        with the given number of bytes, whose contents
                        are undefined, with return of NULL indicating
                        failure.  The memory must be aligned to an
                        8-byte boundary.  Defaults to a call of the C
                        library 'malloc' function.

  sggc_mem_free         May be defined as a simple symbol or as a 
                        one-argument macro (not a function), which is
                        used by SGGC to free blocks of memory that
                        were allocated by sggc_mem_alloc_zero or
                        sggc_mem_alloc.  Defaults to the symbol
                        'free', the C library function.

The alignment requirements above ensure that data areas for objects
are allocated with at least 8-byte alignment.  This alignment may be
increased by defining the following symbol:

  SGGC_DATA_ALIGNMENT   If defined (as a power of two, no larger than
                        32), the data areas of large objects and the
                        shared data areas for small objects will have
                        addresses divisible by SGGC_DATA_ALIGNMENT
                        (unless the data area is smaller than this).

If SGGC_DATA_ALIGNMENT is defined, data areas for all objects will be
guaranteed to have this alignment, _except_ for objects of small kinds
for which the number of chunks specified with SGGC_KIND_CHUNKS results
in a size in bytes that is not divisible by SGGC_DATA_ALIGNMENT.  

Note that an alternative to defining SGGC_DATA_ALIGNMENT is to define
sggc_mem_alloc and sggc_mem_alloc_zero macros that return data blocks
aligned more strictly than the 8-byte alignment required above.

The sggc.h file should be included after the above have been defined,
at the end of sggc-app.h.  It will define the following types:

  sggc_cptr_t           Type for holding a compressed pointer.
                        Currently uint32_t.

  sggc_type_t           Type for holding an object type.
                        Currently unsigned char.

  sggc_kind_t           Type for holding an object kind (type & storage).
                        Currently unsigned char.

The following constants are also defined in sggc.h:

  SGGC_NO_OBJECT        A constant of type sggc_cptr_t that cannot be a
                        reference to an actual object, and hence can be
                        used to indicate "no object".

  SGGC_CHUNKS_IN_SMALL_SEGMENT  The number of chunks (each of size
                                SGGC_CHUNK_SIZE) for the data associated
                                with all objects in a "small" segment.

The sggc.h file will declare the following global structure variable,
which SGGC will continually update with information that the
application may use when deciding whether to call sggc_collect to do a
garbage collection:

  extern struct sggc_info
  {
    unsigned gen0_count;     /* Number of newly-allocated objects */
    unsigned gen1_count;     /* Number of objects in old generation 1 */
    unsigned gen2_count;     /* Number of objects in old generation 2 */
    unsigned uncol_count;    /* Number of uncollected objects */

    size_t gen0_big_chunks;  /* # of chunks in newly-allocated big objects */
    size_t gen1_big_chunks;  /* # of chunks in big objects in old generation 1*/
    size_t gen2_big_chunks;  /* # of chunks in big objects in old generation 2*/
    size_t uncol_big_chunks; /* # of chunks in uncollected big objects */

    unsigned n_segments;     /* Number of segments in use */
    size_t total_mem_usage;  /* Approximate total memory usage (in bytes) */

    uint64_t allocations;    /* Number of objects allocated since startup */
    uint64_t allocations_at_last_gc;  /* # of allocations at time of last GC */

    uint64_t gc_count[3];    /* Counts of collections done at levels 0, 1, 2 */
    uint64_t gc_since_lev12; /* Collections at lev 0 since last at lev 1 or 2 */
    uint64_t gc_since_lev2[2]; /* Collections at levs 0, 1 since last at lev 2*/

  } sggc_info;

Constants are not included in any of the counts or sizes above, except
for n_segments.  Shared read-only auxiliary information areas are also
not counted.  The total memory usage estimate is for physical memory,
and assumes that virtual memory space that has not been used will not
have been assigned physical memory.  It will not include overhead for
malloc or from ensuring alignment according to SGGC_DATA_ALIGNMENT.

The sggc.h file will also declare the array initialized with the
application's definition of SGGC_KIND_CHUNKS in sggc-app.h, as
follows:

  extern const int sggc_kind_chunks[SGGC_N_KINDS];

Finally, the sggc.h file will declare prototypes (or macros, or static
inline definitions) for the functions documented below, some of which
may be used by the application, others of which must be defined by the
application for use by SGGC.

See sggc-imp for how to control some aspects of the implementation,
for which the best choice might depend on the system used.

Invalid values for the constants mentioned above may sometimes be
detected at run-time, in which case the C library "abort" function
will be called.  (It might also be called due to failure of internal
checks, indicative of a bug in the SGGC code.)


TYPES, LENGTHS, AND KINDS

SGGC supports objects that are of different "types", identified by
integers from 0 to SGGC_N_TYPES-1, where SGGC_N_TYPES is defined by
the application (limited to being no bigger than 256).  Types of
objects are recorded by SGGC, but otherwise the meaning of a type is
up to the application.  Note that all objects in a segment will have
the same type.

The application also determines the meaning (if any) of the "length"
of an object - SGGC simply passes length values provided by the
application to functions the application defines.  It would be
possible for the application to completely ignore "length", just
passing some dummy value where a length is required.  More commonly,
however, the length will be used by the application when determining
the "kind" of an object.

All objects in a segment will be of the same kind, identified by a
number from 0 to SGGC_N_KINDS-1, where SGGC_N_KINDS is defined by the
application (limited to being no bigger than 256).  Some kinds are for
"big" segments, which can have data of any size.  Other kinds are for
"small" segments, in which the data associated with an object consists
of a fixed number of chunks (though objects need not use the entirety
of the data space allocated to them).  Whether a kind is for big or
small segments, and the number of chunks allocated for objects if they
are of a small kind, are determined by the value for SGGC_KIND_CHUNKS
that the application provides, which gives the numbers of chunks for
each kind, with zero indicating that the kind uses big segments.

If SGGC_DATA_ALIGNMENT is defined, SGGC_KIND_CHUNKS must be such that
objects with data areas with at least SGGC_DATA_ALIGNMENT bytes have
data areas whose size in bytes is a multiple of SGGC_DATA_ALIGNMENT.

The application provides a function (or macro) sggc_kind that
determines the kind of an object from its type and length.  The kind
returned by sggc_kind must not the same for different types (ie, the
type must be determinable from the kind), but there can be several
kinds for a type that use big segments or small segments, perhaps with
different numbers of data chunks, depending on length.

The application also provides an sggc_nchunks function (or macro) that
returns the number of data chunks needed for an object of given type
and length.  This is called when SGGC needs to allocate space for a
big segment.

For example, the application might have the following definitions in
its sggc-app.h file:

  #define SGGC_CHUNK_SIZE 16 /* Number of bytes in a data chunk */
  #define SGGC_N_TYPES 3     /* Three types of objects: 0, 1, 2 */
  #define SGGC_N_KINDS 5     /* Five kinds of objects 0, 1, 2, 3, 4 */

  #define SGGC_KIND_CHUNKS \
                  { 1,       /* Kind 0 uses 1 data chunk, for type 0 */ \
                    2,       /* Kind 1 uses 2 data chunks, for type 1 */ \
                    0,       /* Kind 2 uses big segments, for type 2 */ \
                    2,       /* Kind 3 uses 2 data chunks, for type 2 */ \
                    6        /* Kind 4 uses 6 data chunks, for type 2 */ \
  }

  #define sggc_kind(type,length) \
    ((type) < 2 ? (type)     /* Types 0 and 1 use kinds 0 and 1 */ \
    : (length) <= 1 ? 3      /* Type 2 with length 1 or less can use kind 3 */ \
    : (length) <= 3 ? 4      /* Type 2 with length 3 or less can use kind 4 */ \
    : 2)                     /* Type 2 with length >3 must use a big segment */

  #define sggc_nchunks(type,length) \
    ((sggc_nchunks_t)(length) * 2) /* Number of chunks needed is twice length */

If an application defines SGGC_KIND_UNCOLLECTED (see above), some
kinds can be for objects that are never collected as garbage.  It is
possible for there to be two kinds for the same type, with the same
number of chunks, with one being for objects that are collected, and
the other for objects that are not collected.  However, since
sggc_alloc uses sggc_kind, which looks only at the type and length,
this would usually need to be accomplished using sggc_alloc_kind,
sggc_alloc_small_kind, or sggc_alloc_small_kind_quickly (see below).

If an application defines the symbols SGGC_AUX1_READ_ONLY, it must
also provide a function called sggc_aux1_read_only that returns a
pointer to read-only auxiliary information 1 for a segment of a given
kind, or NULL if this information is not read-only for segments of
this kind.  Read-only auxiliary information is not allowed for kinds
that use big segments.

If SGGC_AUX2_READ_ONLY is defined, the application must similarly
provide an sggc_aux2_read_only function.


INFORMING SGGC ABOUT OBJECT REFERENCES

The application is responsible for ensuring that the SGGC routines
will be informed of all references to objects (other than uncollected
objects) at any time when sggc_collect is called.  This is done in
three ways.

First, the application must provided an sggc_find_root_ptrs procedure.
This procedure must call the sggc_look_at function (or sggc_mark) for
every "root" compressed pointer, which the application might use to
directly refer to an object.

Root pointers would, for example, include compressed pointers stored
in global variables used by the application.  If the application also
uses regular pointers (to data areas) as roots, sggc_look_at (or
sggc_mark) must be called with the corresponding compressed pointer,
which the application must somehow be able to find (eg, by storing a
compressed pointer to itself at the start of the data area for every
object).

An application may also store root pointers in the local variables of
functions.  The application will need to implement some scheme for
finding all such local variables, and calling sggc_look_at (or
sggc_mark) for each of them, passing the compressed pointer for the
reference.

Secondly, the application must provide an sggc_find_object_ptrs
procedure, which is passed a compressed pointer to an object, and
which must call sggc_look_at for every object that is referenced from
that object (except for constants and uncollected objects).

Finally, the application must call the sggc_old_to_new_check procedure
whenever it may have modified an object in an older generation (or
that is of an uncollected kind) so that it now refers to an object in
a younger generation.  The arguments of sggc_old_to_new_check are a
compressed pointer to an object that has just been modified and a
compressed pointer to the object that it now references.  If
sggc_old_to_new_check sees that the first object is in an older
generation than the second (or in uncollected, with the first not
being uncollected), an appropriate record of this will be kept, so
that the newer object will be recognized as being referenced even if
the older object would not normally be looked at in a partial garbage
collection.

The sggc_old_to_new_check procedure does not have to be called if the
object being modified has just been allocated by sggc_alloc (with no
other calls of sggc_alloc since then), and it is not of an uncollected
kind.  An application can also use the sggc_youngest_generation
function to enquire whether an object is of the youngest generation,
in which case modifications to it do not have to be signaled with
sggc_check_old_to_new (as long as sggc_collect is not called).


FUNCTIONS PROVIDED BY SGGC TO THE APPLICATION

The SGGC library provides an application with the functions (or
macros) below, which have (if functions) prototypes as shown:

  sggc_type_t SGGC_TYPE (sggc_cptr_t cptr)

    Returns the type of the object whose compressed pointer is passed,
    an integer from 0 to SGGC_N_TYPES-1.

  sggc_kind_t SGGC_KIND (sggc_cptr_t cptr)

    Returns the kind of the object whose compressed pointer is passed,
    an integer from 0 to SGGC_N_KIND-1.

  char *SGGC_DATA (sggc_cptr_t cptr)

    Returns a regular pointer to the data associated with the object
    whose compressed pointer is passed.

  char *SGGC_AUX1 (sggc_cptr_t cptr)

    Exists only if the application defines SGGC_AUX1_SIZE in sggc-app.h.  

    Returns a regular pointer to the auxiliary information 1 for the
    object whose compressed pointer is passed.

  char *SGGC_AUX2 (sggc_cptr_t cptr)

    Exists only if the application defines SGGC_AUX2_SIZE in sggc-app.h.  

    Returns a regular pointer to the auxiliary information 2 for the
    object whose compressed pointer is passed.

  sggc_cptr_t SGGC_CPTR_VAL (unsigned index, unsigned offset)

    Returns a compressed pointer constructed from the given segment
    index and offset.  This is needed only in a few specialized
    contexts.

  unsigned SGGC_SEGMENT_INDEX (sggc_cptr_t cptr)

    Returns the segment index of a compressed pointer.  This is needed
    only in a few specialized contexts.

  unsigned SGGC_SEGMENT_OFFSET (sggc_cptr_t cptr)

    Returns the offset within a segment of a compressed pointer.  This
    is needed only in a few specialized contexts.

  int sggc_init (unsigned max_segments)

    Initializes the SGGC facility, with the maximum number of segments
    being as specified, except that this argument is silently reduced
    to SGGC_MAX_SEGMENTS if it is larger, if that constant was
    specified at compile time.  Also silently reduced to the maximum
    allowed by the number of bits in a segment index.  Returns zero if
    no error, and non-zero if allocation failed.

  sggc_cptr_t sggc_alloc (sggc_type_t type, sggc_length_t length)

    Allocates space for an object of the specified type and length,
    returning a compressed pointer to the object, or SGGC_NO_OBJECT if
    space could not be allocated.  If SGGC_NO_OBJECT is returned, it
    is possible that if a garbage collection is then performed using
    sggc_collect, a subsequent call of sggc_alloc for the same type
    and length will succeed (though this will not always be the case).

    Note that the significance of type and length for the storage that
    is needed is determined by the application, via the sggc_kind
    function and the SGGC_KIND_CHUNKS initializer.

    The data area for the newly allocated object will be set to all
    zero bits, but any auxiliary information for the object will have
    undefined contents.

  sggc_cptr_t sggc_alloc_kind (sggc_kind_t kind, sggc_length_t length)

    A faster alternative to sggc_alloc, which exists only if the
    application has defined SGGC_KIND_TYPE (see above).  It takes a
    kind of an object and a length as its arguments.  The type and
    number of chunks needed are determined by this kind and length.
    Note that the length is used only if the kind uses big segments.
    The function otherwise acts the same as sggc_alloc.

    This function and similar ones below are also useful for
    controlling whether an uncollected kind is used, if both collected
    and uncollected kinds exist for a given type and length.

  sggc_cptr_t sggc_alloc_small_kind (sggc_kind_t kind)

    Like sggc_alloc_kind, except no length is specified.  The kind
    passed must therefore use small segments.

  sggc_cptr_t sggc_alloc_small_kind_quickly (sggc_kind_t kind)

    Like sggc_alloc_small_kind, except that it tries to do the
    allocation very quickly (perhaps with inline code), using only
    existing segments, and may return SGGC_NO_OBJECT if this is not
    possible, in which case the application should try calling either
    sggc_alloc_small_kind, sggc_alloc_kind, or sggc_alloc instead.
    Does not require that SGGC_KIND_TYPE be defined.

  sggc_nchunks_t sggc_nchunks_allocated (sggc_cptr_t object)

    Returns the number of chunks actually allocated for the data area
    of the given object, which may be greater than what was asked for
    (indirectly) in the call of sggc_alloc (or related functions).
    The entirety of this allocated can be used by the application.

  void sggc_collect (int level)

    Performs a garbage collection operation, at the specified level.
    Level 0 attempts to recover only unused object that were allocated
    since the last garbage collection.  Level 1 also attempts to
    recover unused objects that have survived one garbage collection
    (only).  Level 2 attempts to recover all unused objects (except
    constants and objects of uncollected kinds).

    Note that this function is never called automatically by SGGC.  
    It is up to the application to implement a policy for when to call
    the garbage collector, and at what level.

  void sggc_look_at (sggc_cptr_t cptr)

    This function must be called from the sggc_find_root_ptrs and
    sggc_find_object_ptrs procedures that the application provides for
    SGGC (and must only be called from these procedures, or from the
    sggc_after_marking procedure).  It signals to SGGC that the object
    referenced by the compressed pointer passed is accessible, via a
    root pointer or via a reference in another object, and hence
    should not be collected.  It also signals that
    sggc_find_object_ptrs should be called (sometime later) to look
    for references within the object.

    It is not necessary (but is allowed) to call sggc_look_at for a
    pointer to a constant object, or an object of an uncollected kind.
    Calling it with SGGC_NO_OBJECT is allowed, and does nothing.

  void sggc_mark (sggc_cptr_t cptr)

    This function is like sggc_look_at, except that it should be
    called only from sggc_find_root_ptrs or from sggc_after_marking
    (not from sggc_find_object_ptrs), and that it does not cause
    sggc_find_object_ptrs to be called to look for references within
    the object.  This procedure should be called instead of
    sggc_look_at only if the application is certain that there are no
    references in the object, or that any such references are to
    objects that will be found by the garbage collector in some other
    way, or are constants or of an uncollected kind.

  void sggc_old_to_new_check (sggc_cptr_t from_ptr, sggc_cptr_t to_ptr)

    This procedure informs SGGC that the application has stored a
    reference to the object pointed to by to_ptr in the object pointed
    to by from_ptr (perhaps in the data area associated with from_ptr,
    or perhaps in the auxiliary information for from_ptr, as either a
    compressed pointer or regular pointer).
  
    The application must call this procedure whenever (ie, just after)
    a reference to another object is stored in an object (including an
    uncollected object, except see below), unless from_ptr can be
    guaranteed to be in the youngest generation of objects, or to_ptr
    is guaranteed to be a constant or of an uncollected kind.  It is
    guaranteed that from_ptr is in the youngest generation if it has
    just been allocated with sggc_alloc, and is not of an uncollected
    kind, or if sggc_youngest_generation says it is in the youngest
    generation, as long as there has been no subsequent call of
    sggc_collect.

    An application may omit calling sggc_old_to_new check when
    from_ptr is an uncollected object if the application will ensure
    that this uncollected object will be examined for references in
    the sggc_after_marking it supplies.

  int sggc_youngest_generation (sggc_cptr_t from_ptr)

    Returns 1 if the object pointed to by from_ptr is in the youngest
    generation - was allocated since the last call of sggc_collect,
    and is not of an uncollected kind - and 0 otherwise.  Note that
    the object will cease to be in the youngest generation after the
    next call of sggc_collect.

  sggc_cptr_t sggc_first_uncollected_of_kind (sggc_kind_t kind)

    Returns a compressed pointer to the first uncollected object of
    the specified kind, in some arbitrary order, or SGGC_NO_OBJECT if
    there are no uncollected objects of that kind.  However, constants
    of uncollected kinds are not included in this set.

  sggc_cptr_t sggc_next_uncollected_of_kind (sggc_cptr_t cptr)

    Returns the next uncollected object of the same kind as cptr, in
    some arbitrary ordering (as for sggc_first_uncollected_of_kind),
    or SGGC_NO_OBJECT if cptr is the last uncollected object of this
    kind.  However, constants of uncollected kinds are not included in
    this set.

  int sggc_is_uncollected (sggc_cptr_t cptr)

    Returns 1 if the given object is of an uncollected kind, and 0
    otherwise.

  sggc_cptr_t sggc_constant (sggc_type_t type, sggc_kind_t kind, 
                             int n_objects, char *data, 
                             char *aux1, char *aux2)

    Creates a segment containing constant objects, and returns the
    compressed pointer to the first object in this segment (compressed
    pointers to the other objects will have the same segment index but
    different offsets).

    The type and kind of the segment are specified by the first two
    arguments.

    The 'n_objects' argument indicates how many objects are in the
    segment.  It must be at least 1, and no more than will fit in a
    segment.

    The 'data' argument is a pointer to the data block for objects in
    this segment.  The 'aux1' and 'aux2' arguments are pointers to the
    auxiliary information for the segment; they exist only if
    SGGC_AUX1_SIZE or SGGC_AUX2_SIZE are defined.

    If called several times before any calls of sggc_alloc (or related
    functions), the segments used will have indexes 0, 1, 2, ... if
    SGGC_NO_OBJECT_ZERO is not defined, and indexes 1, 2, 3, ... if it
    is defined.  This fact may be used when setting up their contents
    if they reference each other.  Constant objects should reference
    only other constant objects.

    Note that although this function is primarily meant for creating
    objects that actually are unchanging constants, an application is
    allowed to change the data or auxiliary information in the object,
    as long as no references to other objects that need to be found by
    the garbage collector are stored there.  If an application never
    modifies a constant segment, it might arrange for it to be in
    read-only memory.

  int sggc_is_constant (sggc_cptr_t cptr)

    Returns 1 if the object is a constant, 0 otherwise.

  int sggc_not_marked (sggc_cptr_t cptr)

    Returns 1 if the object with compressed pointer cptr has not been
    marked as in use during the garbage collection currently under
    way, and 0 if it is marked as in use (including if it is an object
    of an uncollected kind).  This function may be called only from
    the sggc_after_marking procedure, which an application may supply,
    to be called after preliminary marking of objects in use.

  void sggc_call_for_newly_freed_object (sggc_kind_t kind, 
                                         int (*fun) (sggc_cptr_t))

    This procedure tells the garbage collector that at the end of
    every garbage collection (after any call of sggc_after_marking has
    finished) the function 'fun' should be called for every newly-free
    object of the specified kind (in some arbitrary order).  This will
    be done before the data area for the object has been freed.

    The value returned by 'fun' should be 0 if the object should
    indeed be freed, or 1 if the object should not be freed after all.
    Note that if the object is not freed because 'fun' returns 1, any
    references it contains to other objects will NOT be followed to
    see if they also should not be freed.  An application that decides
    to not free an object at this stage must have ensured that no such
    references exist, or that they have ALREADY been marked before
    'fun' was called.  Note also that 'fun' is not allowed to call
    sggc_look_at, sggc_mark, sggc_collect, or sggc_alloc or related
    functions.  The contents of sggc_info are undefined when calls
    to this function are made.

    If 'fun' is 0, any previous set up of a function to call for this
    kind is cancelled.

  void sggc_call_for_object_in_use (void (*fun) (sggc_cptr_t, sggc_nchunks_t))

    This procedure tells the garbage collector that at the end of
    every garbage collection (after any call of sggc_after_marking and
    all calls via sggc_call_for_newly_freed_object) the function 'fun'
    should be called for every object that is still in use (in some
    arbitrary order).  This includes uncollected objects, but not
    constants.  The function will be passed the compressed pointer to
    the object, and the number of chunks in its data area (which may
    be more than was asked for when it was allocated).  The sggc_info
    structure will have been updated to reflect the results of the
    garbage collection before calls to this function are made.

    If 'fun' is 0, any previous set up of a function to call is
    cancelled.

  void sggc_no_reuse (int enable)
  
    If 'enable' is non-zero, newly-freed objects will no longer have
    their data and auxiliary information reused for new objects.  This
    is meant for use as a desparate measure to try to find a bug.  It
    obviously may result in extremely high memory usage.  Calling this
    function with zero for 'enable' will restore normal behaviour for
    the future, but will not recover memory for objects freed when
    'enable' was non-zero.

  sggc_cptr_t sggc_check_valid_cptr (sggc_cptr_t cptr)

    Attempts to cause a program crash if 'cptr' is not a valid
    compressed pointer, to an object that has not been freed.  This is
    done on a "best effort" basis, with no guarantee that all invalid
    pointers cause a crash.  The nature of the crash may vary (eg, a
    memory fault or a call of 'abort').  If 'cptr' is valid, it is
    returned as the value of this function, and this will take a
    fairly small, though not trivial, amount of time.


FUNCTIONS THE APPLICATION MUST PROVIDE TO SGGC

The application defines the following functions called from the SGGC
library functions (which can instead be macros defined in sggc-app.h
before sggc.h is included):

  sggc_kind_t sggc_kind (sggc_type_t type, sggc_length_t length)

    Returns the "kind" of a segment to be used for objects of the
    given type and length, identified by an integer from 0 to
    SGGC_N_KINDS-1.  Must return different kinds for different types.

  sggc_nchunks_t sggc_nchunks (sggc_type_t type, sggc_length_t length)

    Returns the number of data chunks required for an object of the
    given type and length.  Called only when allocating space for big
    segments, so need handle only type and length combinations for
    which sggc_kind returns the kind of a big segment.

  void sggc_find_root_ptrs (void)

    This procedure must call sggc_look_at (or sggc_mark) for every
    "root" pointer via which an object might be referenced, passing
    sggc_look_at (or sggc_mark) the compressed pointer for that
    object.  

    See the discussion above for more context.

  void/sggc_cptr_t sggc_find_object_ptrs (sggc_cptr_t cptr)

    If SGGC_FIND_OBJECT_RETURN is not defined, this procedure must
    call sggc_look_at (not sggc_mark) for every object that is
    referenced via 'cptr' (in any order), passing it the compressed
    pointer to the object that is referenced.  The return type of
    sggc_find_object_ptrs will in this case be void.

    If SGGC_FIND_OBJECT_RETURN is defined (as anything), the return
    type is sggc_cptr_t, and sggc_find_object_ptrs may choose to call
    sggc_look_at for all but one of the referenced objects, and return
    the remaining referenced object as its value - this will slightly
    reduce the overhead of this operation.  If a reference is not
    returned in this way, the value returned by sggc_find_object_ptr
    should be SGGC_NO_OBJECT.

    See the discussion above for more context.

  char *sggc_aux1_read_only (sggc_kind_t kind)

    Only provided if the application defines SGGC_AUX1_READ_ONLY.
    
    Returns a pointer to the shared, read-only auxiliary information 1
    for a segment of the given kind, or NULL if this kind does not use
    read-only auxiliary information 1.  Will not be called with a
    'kind' that uses big segments.

  char *sggc_aux2_read_only (sggc_kind_t kind)

    Only provided if the application defines SGGC_AUX2_READ_ONLY.

    Returns a pointer to the shared, read-only auxiliary information 2
    for a segment of the given kind, or NULL if this kind does not use
    read-only auxiliary information 2.  Will not be called with a
    'kind' that uses big segments.

  void sggc_after_marking (int level, int rep)

    Only provided if the application defines SGGC_AFTER_MARKING.

    Performs whatever operations an application needs to do after the
    preliminary marking stage of a garbage collection.  This may
    involve enquiring about which objects have not already been marked
    as in use, using sggc_not_marked, and perhaps indicating that
    further objects are in use by calling sggc_look_at or sggc_mark.

    If any new objects are looked at, sggc_find_object_ptrs will be
    called to trace further references from these objects, and after
    sggc_after_marking returns, it will then be called again.

    The arguments to sggc_after_marking give the level of garbage
    collection (0, 1, or 2) and the number of previous times that
    sggc_after_marking was called for this collection (zero the first
    time).


DEBUGGING

Very obscure, hard to reproduce, hard to isolate, and highly damaging
bugs can easily arise in a program using SGGC (as in any similar
garbage collection scheme) if the sggc_find_root_ptrs and
sggc_find_object_ptrs functions provided by the application do not
actually find all objects that can still be referenced.  Memory for
objects still in use may then be collected, and reused for other
objects (or it may perhaps become unmapped).

SGGC_CLEAR_FREE and related facilities above are one aid to finding
and isolating such bugs, as is sggc_no_reuse.  

One advantage of SGGC's use of compressed pointers is that minor
changes to a program that do not change allocation behaviour (such as
the addition of print statements for debugging) do not change the
compressed pointers that reference objects, whereas the regular
pointers to the object's data area may change, even when re-running
the program without change (for example, due to "address space layout
randomization").  Accordingly, if a bug is revealed in some run to
relate in some way to an object with a given compressed pointer (which
might have been viewed in a debugger), this object can be investigated
in further runs via this same compressed pointer reference.

To facilitate this investigation, a particular compressed pointer may
be traced by defining the following symbol, in sggc-app.h, or via a
compiler option:

  SGGC_TRACE_CPTR       If defined as an integer, count how many times
                        an object that ends up being referenced by
                        this compressed pointer has been allocated.
                        This count will be kept in the global variable
                        sggc_trace_cptr_count (which might be viewed
                        in a debugger).

The compressed pointer identified by SGGC_TRACE_CPTR may be further
investigated by defining one of the following symbols:

  SGGC_TRACE_ALLOC_TRAP If defined as an integer, call "abort" when an
                        object that becomes associated with the
                        compressed pointer given by SGGC_TRACE_CPTR
                        has been allocated this number of times.  (If
                        undefined or 0, no alloc trapping is done.)

  SGGC_TRACE_FREE_TRAP  If defined as an integer, call "abort" when an
                        object that is referenced by the compressed
                        pointer given by SGGC_TRACE_CPTR has been
                        freed this number of times.  The abort is done
                        before any clearing of the object's data area.
                        (If undefined or 0, no free trapping is done.)
